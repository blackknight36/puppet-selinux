#!/bin/sh
#
# Synopsis:
#       Synchronize Teamcenter Test Server's volume data to that of the
#       Production Server's.  This will perform a destructive operation on
#       Test, but Production should be wholly unaffected.
#
# Usage:
#       teamcenter-sync [ --dry-run ] TARGET
#
#       TARGET is the host name providing the shares to be synchronized and
#       must be one of: mas-cad23 or mas-cad26.
#
#       The --dry-run option may be specified to to just see what would be
#       done, without making any changes at all.
#
# Examples:
#
#       Do a non-destructive mock run to synchronize mas-cad23 with the
#       Production source (i.e., //<%= @sync_source %>/volumes).
#
#               teamcenter-sync --dry-run mas-cad23
#
#       Do whatever is necessary to make mas-cad26 just like the Production
#       source:
#
#               teamcenter-sync mas-cad26
#
# Warning:
#       This file is managed by puppet.  Any changes made locally here will be
#       overwritten.  The origin of this file on the puppet master is:
#
#               modules/dart/files/tc_util/teamcenter-sync
#
# Author:
#       John Florian <john.florian@dart.biz>
#
#


fail() {
    echo -e >&2 "ERROR: $@"
    exit 64
}

warn() {
    echo >&2 "WARNING: $@"
}

mounted() {
    # Test a mount point to determine something is mounted there or not.
    #
    # @1:       Mount point to be tested.
    # @returns: 0 iff mounted; not 0 otherwise.
    what="$(readlink -f $1)"
    grep -q "$what" /proc/mounts
}

# Note: Trailing slash is critical and must be present!
SOURCE='/srv/<%= @sync_source %>-volumes/'
TARGET=''

# A space delimited list of who will receive the operations log.
MAILTO="forrest.styx@dart.biz arul.jaganathan@dart.biz"


# Don't change anything below this point, unless you know what you're doing.
SELF="$(basename $0)"
ERR="/var/tmp/${SELF}-${USER}.err"
LOG="/var/tmp/${SELF}-${USER}.log"
LOGZ="${LOG}.zip"

# Parse options and arguments from the command-line.
rsync_opts=''
while [ $# -gt 0 ]
do
    word="$1"
    shift
    case "$word" in
        --dry-run )
            rsync_opts="$rsync_opts $word"
            ;;
        -* )
            warn "ignoring unknown option: $word"
            ;;
        mas-cad23 | mas-cad26 )
            TARGET="/srv/$word-volumes/"
            break
            ;;
        * )
            fail "unknown TARGET '$word'\nvalid are: mas-cad23 and mas-cad26"
            ;;
    esac
done
[ $# -eq 0 ] || warn "ignoring unexpected arguments: $@"
[ -n "$TARGET" ] || fail "missing required argument: TARGET"

mounted "$SOURCE" \
    || fail "Cannot continue because SOURCE '${SOURCE}' is not mounted."

mounted "$TARGET" \
    || fail "Cannot continue because TARGET '${TARGET}' is not mounted."

# Establish a crude real-time log monitor to provide immediate feedback of
# progress (and errors) to the user.
> "$LOG" > "$ERR"
tail -F "$LOG" "$ERR" &

# Do the actual synchronization of TARGET with SOURCE, honoring any additional
# command-line options (e.g., --dry-run) that may have been passed.  Send all
# stdout/stderr on stdout, but also capture both in LOG.
beg_time="$(date)"
time rsync \
    --delete \
    --hard-links \
    --human-readable \
    --links \
    --progress \
    --recursive \
    --stats \
    --times \
    --verbose \
    $rsync_opts \
    "$SOURCE" "$TARGET" \
    > "$LOG" 2> "$ERR"
end_time="$(date)"

# Terminate the log monitor process (tail -F ...)
kill %1 &> /dev/null

# Compress LOG and mail it to MAILTO as an attachment.
rm -f $LOGZ &> /dev/null
zip --junk-paths -q --to-crlf "$LOGZ" "$LOG"
mailx \
    -a "$LOGZ" \
    -r "${SELF}-no-reply@$HOSTNAME" \
    -s "Teamcenter Volume Synchronization for $TARGET on $beg_time" \
    $MAILTO <<EOF
This mail provides the results of the Teamcenter Volume synchronization tool for the execution initiated on $beg_time.  Below you may find a quick summary of the overall process and any errors that were encountered.  Also, a log of all synchronization actions may be found in the attached file.

Quick Details:
                    Start Time:  $beg_time
                      End Time:  $end_time
$(awk -F: '/^Number of files:/,/^ *Total bytes received:/{printf "%30s:\t%s\n", $1, $2}' $LOG)
$(tail -3 $LOG)

== Error Report ==
$(test -s $ERR && cat $ERR || echo 'No errors occurred.')
== End of Error Report ==

This is system-generated mail from the script "$0" located on $HOSTNAME.
EOF

exit 0
